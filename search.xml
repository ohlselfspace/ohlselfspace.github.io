<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络编程</title>
      <link href="/2020/02/06/wang-luo-bian-cheng/"/>
      <url>/2020/02/06/wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程（<strong>Computer network programming</strong>）是指计算机网络编程涉及编写使程序能够跨计算机网络相互通信的计算机程序。</p><p>三要素：</p><ul><li>协议</li><li><strong>IP</strong>地址</li><li>端口号</li></ul><hr><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>计算机使多台计算机实现连接通信，其连接和通行时需要遵守一定的规则。它对数据的传输格式、传输速率、传输步骤做了统一的规定，定义了实现的标准。</p><p><img src="tcp_ip.jpg" alt></p><p><code>java.net</code>包下提供了两种常见的网络协议：</p><ul><li><p><strong>TCP/IP</strong>: 传输控制协议/因特网互联协议( <strong>Transmission Control Protocol/Internet Protocol</strong>)，是<strong>Internet</strong>最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p></li><li><p><strong>UDP</strong>:用户数据报协议(<strong>User Datagram Protocol</strong>)。<strong>UDP</strong>是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p></li></ul><hr><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p><strong>IP</strong>地址是指互联网协议地址（<strong>Internet Protocol Address</strong>），<strong>IP</strong>地址用来个网络中的计算机设备做唯一的编号。</p><p><strong>IP地址分类</strong></p><ul><li><strong>IPv4</strong>，是一个32位的二进制数，通常被分为4个字节。2019年11 月 25 日，全球五大区域互联网注册管理机构之一的欧洲网络协调中心（<strong>RIPE NCC</strong>）宣布 <strong>IPv4</strong> 地址已全部用完。</li><li><strong>IPv6</strong>，采用128位地址长度，每16个字节一组，分成8组十六进制数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套接字 </tag>
            
            <tag> C/S </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git三剑客</title>
      <link href="/2020/02/02/git/"/>
      <url>/2020/02/02/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>Git</strong>作为世界上最新进的分布式版本控制系统，用于高效处理任何项目。</p><hr><h2 id="配置user信息"><a href="#配置user信息" class="headerlink" title="配置user信息"></a>配置user信息</h2><ul><li>$ git config –global user.name “your_name”</li><li>$ git config –global user.email “<a href="mailto:your_email@domain.com" target="_blank" rel="noopener">your_email@domain.com</a>“</li></ul><blockquote><p>config的三个作用域</p><ul><li>git config –local （只对某个仓库有效）</li><li>git config –global （对当前用户所有仓库有效）</li><li>git config –system（对系统所有登录用户有效）</li></ul><p>显示config的配置，加  –list</p><p>git config –list –XXX</p></blockquote><hr><h2 id="建Git仓库"><a href="#建Git仓库" class="headerlink" title="建Git仓库"></a>建Git仓库</h2><p>两种场景：</p><p>1.把已有的项目代码纳入<strong>Git</strong>管理</p><pre class="line-numbers language-git"><code class="language-git">$ cd 项目代码所在文件夹<span class="token command">$ git init</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.新建的项目直接用<strong>Git</strong>管理</p><pre class="line-numbers language-git"><code class="language-git">$ cd 某个文件夹<span class="token command">$ git init your_project  #会在当前路径下创建和项目名称相同的文件夹</span>$ cd your_project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>当设置global参数后，再设置local参数，local的优先级更高</p></blockquote><h2 id="往仓库里添加文件以及常用命令"><a href="#往仓库里添加文件以及常用命令" class="headerlink" title="往仓库里添加文件以及常用命令"></a>往仓库里添加文件以及常用命令</h2><p><img src="0.png" alt></p><pre class="line-numbers language-git"><code class="language-git">Git常用命令<span class="token command">$ git add xxx #把xxx添加到仓库</span><span class="token command">$ git commit<span class="token parameter"> -m</span> </span><span class="token string">"xxx"</span> #把文件提交到仓库，xxx表示此次提交的信息<span class="token command">$ git status #查看仓库当前状态</span><span class="token command">$ git diff xxx #查看xxx修改内容</span><span class="token command">$ git log #显示提交的日志</span><span class="token command">$ git log<span class="token parameter"> --oneline</span> #查看简洁方式<span class="token parameter"> --n4</span> #所有分支最近4个<span class="token parameter"> --graph</span> #图形化</span><span class="token command">$ git reflog #查看命令历史</span><span class="token command">$ git reset<span class="token parameter"> --hard</span> commit_id #回退到某个版本</span><span class="token command">$ git mv xxx xxx.md #把xxx变更xxx.md文件名</span>$ gitk #图形界面查看版本历史<span class="token command">$ git checkout #切换分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="commit，tree和blob三个对象之间的关系"><a href="#commit，tree和blob三个对象之间的关系" class="headerlink" title="commit，tree和blob三个对象之间的关系"></a>commit，tree和blob三个对象之间的关系</h2><p>在<strong>Git</strong>中根据哈希值，像commit—&gt;tree—&gt;blob这样的树形结构连接起来。</p><p><strong>Git</strong>中不会因为文件名不同而创建不同的<strong>blob</strong>文件，而是根据哈希值来确定<strong>blob</strong>文件，这样就大大节省了<strong>Git</strong>仓库的空间大小。</p><hr><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>如果进行了某些更改，而且十分重要，一定要和某个分支绑定在一起，<strong>Git</strong>才不会把它作为垃圾处理。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发实现和线程安全</title>
      <link href="/2020/02/02/java-bing-fa-shi-xian-he-xian-cheng-an-quan/"/>
      <url>/2020/02/02/java-bing-fa-shi-xian-he-xian-cheng-an-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程（<strong>Thread</strong>），通常是指每一个任务。多线程就是指可以同时运行一个以上线程的程序。多线程执行时，在栈内存中，每一个执行的线程都有一片自己的栈内存空间。进行方法的压栈、弹栈。</p><hr><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li><strong>New</strong>（新创建）</li><li><strong>Runnable</strong>（可运行）</li><li><strong>Blocked</strong>（被阻塞）</li><li><strong>Waiting</strong>（等待）</li><li><strong>Timed waiting</strong>（计时等待）</li><li><strong>Terminated</strong>（被终止）</li></ul><h3 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1.线程创建"></a>1.线程创建</h3><h4 id="1-1Thread类实现"><a href="#1-1Thread类实现" class="headerlink" title="1.1Thread类实现"></a>1.1Thread类实现</h4><p><strong>JAVA</strong>中使用<code>java.lang.Thread</code>类代表线程，所有的线程对象必须是<strong>Thread</strong>类或者其子类的实例。</p><p>创建多线程步骤：</p><ul><li>1.定义<strong>Thread</strong>类的子类，重写<strong>run</strong>方法（线程执行体）</li><li>2.创建<strong>Thread</strong>子类的实例，可运用多态来创建线程对象</li><li>3.调用线程对象的<strong>start</strong>（）来启动线程</li></ul><blockquote><p>注意：</p><p>应该是调用start（）方法，而不是run（）方法。</p><p>如果调用的是run（）方法，那么只会在main方法的栈空间运行run（）中的代码，而不会开辟新的栈空间。这就不是多线程</p></blockquote><p><code>java.lang.Thread</code>类<strong>API</strong>中的一些方法：</p><p><strong>构造方法</strong>：</p><ul><li><code>public Thread()</code>:分配一个新的线程对象</li><li><code>public Thread(String name)</code>:分配一个指定参数名的线程对象</li><li><code>public Thread(Runnable target)</code>:分配一个带有指定目标新的线程对象</li><li><code>public Thread(Runnable target,String name)</code>:分配一个带有指定目标新的线程对象并指定参数名</li></ul><p><strong>常用方法</strong>：</p><ul><li><code>public String getName()</code>:获取当前线程名称</li><li><code>public void start()</code>:让此线程开始执行，<strong>JVM</strong>调用<strong>run（）</strong>方法</li><li><code>public void run()</code>：此线程要执行的任务代码</li><li><code>public static void sleep(long millis)</code>:使当前正在执行的线程暂停多少毫秒再执行</li><li><code>public static Thread currentThread()</code>:返回当前正在执行的线程对象的引用</li></ul><hr><h4 id="1-2Runnable接口实现"><a href="#1-2Runnable接口实现" class="headerlink" title="1.2Runnable接口实现"></a>1.2Runnable接口实现</h4><p>采用<code>java.lang.Runnable</code>接口，重写<strong>run（）</strong>方法</p><p>创建多线程步骤：</p><ul><li>1.定义<strong>Runnable</strong>接口的实现类，重写<strong>run（）</strong>方法</li><li>2.创建<strong>Runnable</strong>实现类的实例，并以实例作为<strong>Thread</strong>的<strong>target</strong>来穿件<strong>Thread</strong>对象，该<strong>Thread</strong>对象才是真正的线程对象</li><li>调用线程对象的<strong>start（）</strong>方法来启动线程</li></ul><hr><h4 id="1-3Thread和Runnable区别"><a href="#1-3Thread和Runnable区别" class="headerlink" title="1.3Thread和Runnable区别"></a>1.3Thread和Runnable区别</h4><ul><li>使用<strong>Thread</strong>继承方法实现多线程不适合资源贡献</li><li><strong>Runnable</strong>接口比<strong>Thread</strong>继承更有优势<ul><li>适合多个相同的程序代码的线程去共享一个资源</li><li>避免<strong>JAVA</strong>中单继承局限性</li><li>有利于程序解耦，实现设置线程任务和开启线程分离</li><li>线程池只能放入<strong>Runnable</strong>或<strong>Callable</strong>类线程，不能直接放入继承<strong>Thread</strong>类</li></ul></li></ul><blockquote><p>注意：</p><p>在JAVA中，每次程序运行至少启动两个线程。一个是main线程，一个是垃圾收集线程。</p></blockquote><h4 id="1-4匿名内部类实现线程创建"><a href="#1-4匿名内部类实现线程创建" class="headerlink" title="1.4匿名内部类实现线程创建"></a>1.4匿名内部类实现线程创建</h4><p>使用匿名内部类方式，可以方便实现每个线程任务操作。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*    Runnable是函数式接口，可以使用lambda表达式建立一个实例    格式：        Runnable r = ()->{ code }*/</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        执行代码    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token number">2</span><span class="token punctuation">.</span>Runnable r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        执行代码    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2.线程安全"></a>2.线程安全</h3><p>线程安全是由全局变量和静态变量引起，涉及到程序中共享资源的操作</p><p><strong>线程同步机制</strong></p><p><strong>JAVA</strong>中线程同步机制：</p><ul><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ul><p><strong>JAVA</strong>中同步机制<code>synchronized</code>关键字</p><hr><h4 id="2-1同步代码块"><a href="#2-1同步代码块" class="headerlink" title="2.1同步代码块"></a>2.1同步代码块</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>同步锁<span class="token punctuation">)</span><span class="token punctuation">{</span>    同步操作代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>对象的同步锁是在对象上标记了一个锁</p><ul><li>1.锁对象可以是任意类型</li><li>2.多个线程对象要使用对一把锁，哪个线程拿到了锁就进入<strong>Runnable</strong>状态，没有得到锁的线程进入<strong>Blocked</strong>状态</li></ul></blockquote><hr><h4 id="2-2同步方法"><a href="#2-2同步方法" class="headerlink" title="2.2同步方法"></a>2.2同步方法</h4><p>同步方法是指，<code>synchronized</code>修饰的方法，保证只有一个线程使用同步方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    执行代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ul><li>1.对于非<strong>static</strong>方法，同步锁就是<strong>this</strong></li><li>2.对于<strong>static</strong>方法，同步锁就是当前当前方法所在来的字节码对象（类名.class)反射机制</li></ul></blockquote><hr><h4 id="2-3Lock锁"><a href="#2-3Lock锁" class="headerlink" title="2.3Lock锁"></a>2.3Lock锁</h4><p><code>ReentrantLock</code>类继承自<code>Lock</code>类，显式就行加锁。</p><pre class="line-numbers language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//多态</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//加同步锁</span>    执行代码    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//释放同步锁</span>    <span class="token comment" spellcheck="true">/*        这里可以采用异常处理机制        lock.lock();        try{        执行代码        }finally{        lock.unlock();}    */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ul><li>1.如果使用锁，就不能使用带资源的<strong>try</strong>语句</li><li>2.把解锁操作放在<strong>finally</strong>中至关重要。如果在临界区中的代码抛出异常，锁必须被释放。否则，其他线程将永远被阻塞</li></ul></blockquote><hr><h1 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h1><p>等待唤醒机制是多线程一种协作机制，用来合理调度资源。</p><p>等待唤醒的方法：</p><ul><li><strong>wait</strong>：线程停止活动，不再参与调度，进入<strong>wait set</strong></li><li><strong>notify</strong>： 选取通知对象中的<strong>wait set</strong>中的一个线程进行释放</li><li><strong>notify</strong>：释放通知对象的<strong>wait set</strong>中的全部线程</li></ul><blockquote><p>注意：</p><ul><li><strong>wait</strong>方法与<strong>notify</strong>方法必要由同一个锁对象调用</li><li><strong>wait</strong>方法与<strong>notify</strong>方法属于<strong>Object</strong>类的方法</li><li><strong>wait</strong>方法与<strong>notify</strong>方法必要在同步代码块或者同步函数中使用</li></ul></blockquote><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<strong>JAVA</strong>核心技术》</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 线程 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Exception和Error</title>
      <link href="/2020/02/01/qian-xi-exception-he-error/"/>
      <url>/2020/02/01/qian-xi-exception-he-error/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA异常层次结构"><a href="#JAVA异常层次结构" class="headerlink" title="JAVA异常层次结构"></a>JAVA异常层次结构</h1><p><code>JAVA</code>中所有异常都是由<code>Throwable</code>继承而来，异常层次结构可从<code>Throwable</code>超类向下分为<code>Exception</code>,<code>Error</code>两个子类。</p><p><img src="0.png" alt></p><hr><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><code>Exception</code>是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理。该层次结构分解为两个分支<code>IOException</code>,<code>RuntimeException</code>。划分这两个层次的规则是：由程序错误导致的异常属于<code>RuntimeException</code>;而程序本身没有问题，但由于像I/O错误这类问题导致的异常就属于<code>IOException</code>。</p><p><code>RuntimeException</code>的异常通常包含以下方面：</p><ul><li><code>ClassCastException</code></li><li><code>NullPointerException</code></li><li><code>ArrayIndexOutOfBoundsException</code></li><li><code>SecurityException</code></li></ul><p><code>IOException</code>的异常通常包含：</p><ul><li><code>Checked Exception</code>，就是必须显式地进行捕获处理，这是编译器检查的一部分。</li><li>试图在文件的尾部读取数据</li><li>试图打开一个不存在的文件</li><li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在</li></ul><hr><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p><code>Error</code>类层次结构描述了<code>JAVA</code>运行时系统内部错误和资源耗尽错误。绝大部分的<code>Error</code>都会导致程序（比如<code>JVM</code>自身）处于非正常的、不可恢复状态。常见比如：</p><ul><li><code>OutOfMemoryError</code></li><li><code>NoClassDefFoundError</code></li></ul><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><code>java</code>异常处理五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h3 id="1-抛出异常throw"><a href="#1-抛出异常throw" class="headerlink" title="1.抛出异常throw"></a>1.抛出异常throw</h3><p><strong>throw</strong>：用来抛出一个指定的异常对象。<strong>throw</strong>用在方法中，用来抛出一个异常对象，将这个异常对象传递到调用者出，并结束当前方法的执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> 异常类名（参数）：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><ul><li>1.<strong>throw</strong>关键字必须写在方法的内部</li><li>2.<strong>throw</strong>关键字后边<strong>new</strong>的对象必须是<strong>Exception</strong>或者<strong>Exception</strong>的子类对象</li><li>3.<strong>throw</strong>关键字抛出指定的异常对象，就必须处理这个异常对象<ul><li><strong>throw</strong>关键字后边创建的是<strong>RuntimeException</strong>或者是<strong>RuntimeException</strong>子类对象，可以不处理，默认交给<strong>JVM</strong>处理（打印异常对象，中断程序）</li><li><strong>throw</strong>关键字后边创建的是编译异常，必须使用throws或者try…catch处理</li></ul></li></ul><hr><h3 id="2-声明异常throws"><a href="#2-声明异常throws" class="headerlink" title="2.声明异常throws"></a>2.声明异常throws</h3><p><strong>throws</strong>会把异常对象声明抛出给方法的调用者处理</p><pre class="line-numbers language-java"><code class="language-java">修饰符 返回值类型 方法名（参数列表） <span class="token keyword">throws</span> AException，BException<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AException</span><span class="token punctuation">(</span><span class="token string">"原因1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BException</span><span class="token punctuation">(</span><span class="token string">"原因2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>1.<strong>throws</strong>关键字必须写在方法声明处</li><li>2.<strong>throws</strong>关键字后边声明的异常必须是Exception或者是Exception的子类</li><li>3.方法内部如果抛出了多个异常对象，那么throws后边也必须声明多个异常<ul><li>如果抛出的多个异常对象有子父类关系，直接声明父类对象</li></ul></li><li>4.调用了一个声明抛出异常的方法，就必须处理声明的异常<ul><li>要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM</li><li>要么try…catch自己处理异常</li></ul></li></ul><hr><h3 id="3-try…catch"><a href="#3-try…catch" class="headerlink" title="3.try…catch"></a>3.try…catch</h3><p>捕获异常可设置<code>try/catch</code>语句</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*    如果在try语句块中的代码没有抛出任何异常，那么程序将跳过catch字句*/</span><span class="token keyword">try</span><span class="token punctuation">{</span>    编写可能会出现异常的代码<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型 e<span class="token punctuation">)</span><span class="token punctuation">{</span>    处理异常<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>1.<strong>try</strong>中可能会抛出多个异常对象，那么就可以使用多个<strong>catch</strong>来处理这些异常</li><li>2.如果<strong>try</strong>中产生了异常，那么就会执行catch中的异常处理语句，执行完毕后继续下面的代码；如果<strong>try</strong>中没有产生异常，那么就不会执行catch中处理异常的语句，继续执行<strong>try…catch</strong>之后的代码</li></ul><p>如何获取异常信息：</p><p><strong>Throwable</strong>类中定义了一些查看方法:</p><ul><li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li></ul><ul><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li><li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li></ul><hr><h3 id="4-finally"><a href="#4-finally" class="headerlink" title="4.finally"></a>4.finally</h3><p><strong>finally</strong>：有一些代码无论异常是否发生，都需要执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    执行代码<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">{</span>    处理异常<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    无论程序怎样，最终执行代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>主要在<strong>finally</strong>中处理<strong>return</strong>语句</li><li>慎用<strong>return，break，continue</strong></li><li>对于引用类型返回，要特别小心。如果在<strong>finally</strong>中改变了引用对象的成员属性，即使不显式地调用<strong>return</strong>语句，修改也会作用到返回值上</li></ul><h3 id="5-多异常处理"><a href="#5-多异常处理" class="headerlink" title="5.多异常处理"></a>5.多异常处理</h3><ul><li>多个异常分别处理</li><li>多个异常一次捕获，多次处理</li><li>多个异常一次捕获一次处理</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*    最常用的是一次捕获多次处理方式*/</span><span class="token keyword">try</span><span class="token punctuation">{</span>     编写可能会出现异常的代码<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型A  e<span class="token punctuation">)</span><span class="token punctuation">{</span>  当<span class="token keyword">try</span>中出现A类型异常<span class="token punctuation">,</span>就用该<span class="token keyword">catch</span>来捕获<span class="token punctuation">.</span>     处理异常的代码     <span class="token comment" spellcheck="true">//记录日志/打印异常信息/继续抛出异常</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型B  e<span class="token punctuation">)</span><span class="token punctuation">{</span>  当<span class="token keyword">try</span>中出现B类型异常<span class="token punctuation">,</span>就用该<span class="token keyword">catch</span>来捕获<span class="token punctuation">.</span>     处理异常的代码     <span class="token comment" spellcheck="true">//记录日志/打印异常信息/继续抛出异常</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>运行时异常被抛出可以不处理，不捕获也不抛出</li><li>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常</li><li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</li></ul><hr><h3 id="6-自定义异常类"><a href="#6-自定义异常类" class="headerlink" title="6.自定义异常类"></a>6.自定义异常类</h3><p>对于<strong>JAVA</strong>提供的异常类，不够使用，需要自己定义一些异常类</p><pre class="line-numbers language-java"><code class="language-java">格式：<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XXXException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token operator">/</span>RuntiimeException<span class="token punctuation">{</span>    添加一个空参数构造器    添加一个带异常信息的构造器<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>自定义异常类一般都是<strong>Exception</strong>结尾，说明该类是一个异常类</li><li>自定义异常类，必须继承<strong>Exception</strong>或者<strong>RuntimeException</strong><ul><li>继承<strong>Exception</strong>：那么自定义异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理异常，<strong>throws</strong>或者<strong>try…catch</strong></li><li>继承<strong>RuntimeException</strong>：那么自定义异常类就是一个运行期异常，无需处理，交给<strong>JVM</strong>处理</li></ul></li></ul><hr><h1 id="异常机制的使用技巧"><a href="#异常机制的使用技巧" class="headerlink" title="异常机制的使用技巧"></a>异常机制的使用技巧</h1><ul><li>异常处理不能代替简单的测试</li><li>不要过分地细化异常</li><li>尽量不要捕获类似<strong>Exception</strong>这样的通用异常，而是捕获特定异常</li><li>不要生吞（swallow）异常</li><li>利用异常层次结构<ul><li>不要只抛出<strong>RuntimeException</strong>异常。应该寻找更加合适的子类或创建自己的异常类</li><li>不要只捕获<strong>Thowable</strong>异常，否则会使程序代码更难维护</li></ul></li><li>早抛出，晚捕获</li></ul><hr><h1 id="性能角度分析"><a href="#性能角度分析" class="headerlink" title="性能角度分析"></a>性能角度分析</h1><ul><li><strong>try…catch</strong>代码段会产生额外的性能开销，往往会影响<strong>JVM</strong>对代码的优化，所以建议只捕获有必要的代码段</li><li>利用异常控制代码流程，效果也不是很好，通常比条件语句更加低效</li></ul><hr><h1 id="NoClassDefFoundError，ClassNotFoundException辨析"><a href="#NoClassDefFoundError，ClassNotFoundException辨析" class="headerlink" title="NoClassDefFoundError，ClassNotFoundException辨析"></a>NoClassDefFoundError，ClassNotFoundException辨析</h1><p><code>ClassNotFoundException</code>产生的原因：</p><p><strong>JAVA</strong>支持使用<strong>Class.forName</strong>方法动态加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到<strong>JVM</strong>内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出<strong>ClassNotFoundException</strong>异常。</p><p><code>NoClassDefFoundError</code>产生的原因：</p><p>如果<strong>JVM</strong>或者<strong>ClassLoader</strong>实例尝试加载（可以通过正常的方法调用，也可能是使用<strong>new</strong>来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>《<strong>JAVA</strong>核心技术》</p></li><li><p><a href="https://time.geekbang.org/column/intro/82" target="_blank" rel="noopener"><strong>JAVA</strong>核心技术36讲</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA异常 </tag>
            
            <tag> 捕获异常 </tag>
            
            <tag> Throwable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年总结</title>
      <link href="/2020/01/30/2019-nian-zong-jie/"/>
      <url>/2020/01/30/2019-nian-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=441532&auto=1&height=66"></iframe></div><h1 id="纪念2019年流逝的时光"><a href="#纪念2019年流逝的时光" class="headerlink" title="纪念2019年流逝的时光"></a>纪念2019年流逝的时光</h1><hr><ul><li><h2 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h2><p>2019年经历了许多有趣、难忘的事，从大一的荒废时间，到后来终于幡然醒悟。人生就是这样兜兜转转，但是最终却要把人带回应该要走的轨迹。</p><p>这一年里，面临着考研和工作的选择，选择考研这一条毫无硝烟的战役。既是对人内心的磨炼，也是对以前所欠缺的知识进行了一场恶补。不论结果如何，都是对自己大学生涯的总结。若干年后，至少心中不会抱有遗憾。</p><p><img src="0.jpg" alt></p></li></ul><ul><li><h2 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h2><blockquote><p>How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face.</p></blockquote><p>18年4年，遇见了她。是偶然，也是必然。我相信人生你注定要遇见的，经历的，是你逃不掉，最终必然注定的。她像一团光，那么耀眼，能够将我轻易融化。从最初表白失败到最后在一起，中间的过程是那么曲折。但是，很高兴我找到能够相伴一生的人。</p><p><img src="1.jpg" alt></p><hr></li></ul><ul><li><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><blockquote><p>时至今日你仍是我是我心中的光。——《非自然死亡》 </p></blockquote><p>未来仍将努力前行。</p><p><img src="2.jpg" alt></p><hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱情 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
